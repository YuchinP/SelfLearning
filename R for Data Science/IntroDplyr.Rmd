---
title: "dplyr"
author: "Yuchin Stone Pan"
date: "February 20, 2018"
output: html_document
---


This is an introduction to using dplyr. Very infrequently do we receive data in the correct format we need to create visualizations from. 
Often we will need to rename variables, create new ones, re-order observations, or any kind of transformation that will make it more digestible to work with.

We will do this learning the dyplr package and a new dataset on flights departing NYC in 2013.

```
library(nycflights13)
library(tidyverse)
```

We'll start by exploring the dataset


```
flights
```

This will output the first 10 of 33,776 rows and 10 of 19 columns. This is called a Tibble, a dataframe tweaked to work better in the tidyverse.

The various data types for reference
  int =  integer
  dbl = doubles or real numbers
  chr = character vectors or strings
  dttm = date-times
  
  lgl = logical (true or false)
  fctr = factor, categorical variables with fixed possible values (green, yellow, red)
  date = dates
  
## 5 keys

There are 5 key dplyr functions we will learn that will cover most of the data manipulation
  Pick observations by their values *Filter()*
  Reorder the rows *arrange()*
  Pick variables by their name *select()*
  Create new variables with functions of existing variables *Mutate()*
  Collapse many values down to a single summary *Summarize()*
  
These can all be used in conjunction with group_by() which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. These 6 functions provide the verbs for data manipulation.

All verbs work similarly:
  1. The first argument is a data frame
  2. The subsequent arguments describe what to do with the data frame, using the variable names
  3. The result is a new data frame
  
### Filter
Filter allows us to subset observations based on their values.

For example we want o see all flights on January 1st.
```
filter(flights, month == 1, day == 1)
```
This returns the result, but if we want to continue using it we need to save it to a variable.

```
jan1 <- filter(flights, month == 1, day == 1)
```

If you want execute AND assign a variable wrap it all in parenthesis.

```
(dec25 <- filter(flights, month == 12, day == 25))
```

#### Comparisons
To use filtering effectively, you have to know how to select the observations that you want using the comparison operatiors. R provides the usual
  >
  >=
  <
  <=
  != not equal
  == equal
  
  Remember every number you see when using R is an approximation. Instead of relying on ==, use *near()*
  
#### Logical Operators
Multiple arguments to filter() are combined "and"
  Every expression must be true in order for a row to be included in the output
  
For other types of combinations you'll us
  & = and
  | = or
  ! = not

All flights in either Novemeber or December
```
filter(flights, month == 11 | month == 12)
```
More likely we want to us the in

```
nov_dec <- filter(flights, month %in% c(11,12))
nov_dec
```

#### Missing Values

One thing that will make running functions tough are missing values or NAs

In order to find out if a value is missing we use *is.na()*

filter() only includes rows where the condition is TRUE, excluding both FALSE and NA values.
  However if we want to keep them explicitly put them in.
  
```
df <- tibble(x = c(1,NA,3))
filter(df, x>1)

filter(df, is.na(x) | x >1)
```
#### Arrange Rows with arrange()
Arrange is similar to filter except instead of selecting rows, it changes the order.

It requires a data frame and a set of column names. 

```
arrange(flights, year, month, day)
```

On the other hand you can use desc to order in descending order.

```
arrange(flights, desc(arr_delay))
```

Missing values will always be sorted at the end

```
df <- tibble(x = c(5,2,NA))
arrange(df,x)
arrange(df, desc(x))
```

```
arrange(df, desc(is.na(x)))

arrange(flights, desc(dep_delay))
arrange(flights, dep_time)

arrange(flights, air_time)

arrange(flights, desc(distance))
arrange(flights, distance)
```

#### Select Columns with select()
Select allows you to find a subset of data. 

```
select(flights, year, month, day)

select(flights, year:day)

select(flights, -(year:day))

select(flights, starts_with("abc"))

select(flights, ends_with("xyz"))

select(flights, contains"ijk")

select(flights, "(.)\\1")

select(flights, num_range("x", 1:3))
```

Select can also be used to rename variables, but it drops all the variables not explicitly mentioned. rename()

A good way to get the rest of the columns is to use everything()

```
select(flights, month, month)
```

#### Add New Variables with mutate()
Mutate() always add new columns at the end of the dataset. 

```
flights_small <- select(flights,
year:day, ends_with("delay"),
distance,
air_time
)

mutate(flights_small,
gain = arr_delay - dep_delay,
speed = distance / air_time*60)
```

Note: If you only want to keep the new variables use transmute()

Modular Arithmatic
(%/% and %%)
%/% = integer division
%% = remainder

```
transmute(flights,
dep_time,
hour = dep_time %/% 100,
minute = dep_time %% 100)
```
R provides functions for running sums, products, mins and maxesL
  cumsum()
  cumprod()
  cummin()
  cummax()
  
